// jsOTP.min.js
(function(window){
    'use strict';
    
    // Base32 encoding/decoding
    const base32chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    const base32Map = {};
    for(let i = 0; i < base32chars.length; i++) {
        base32Map[base32chars[i]] = i;
    }

    const base32Decode = function(str) {
        if (!str) return '';
        
        // Remove padding and convert to uppercase
        str = str.replace(/=+$/, '').toUpperCase();
        
        let decoded = [];
        let bits = 0;
        let current = 0;
        
        for(let i = 0; i < str.length; i++) {
            const val = base32Map[str[i]];
            if (val === undefined) throw new Error('Invalid base32 character: ' + str[i]);
            
            current = (current << 5) | val;
            bits += 5;
            
            if (bits >= 8) {
                decoded.push((current >> (bits - 8)) & 255);
                bits -= 8;
            }
        }
        
        return new Uint8Array(decoded);
    };

    // HMAC-SHA1 implementation
    const hmacSha1 = function(key, message) {
        const hashLength = 20; // SHA1 hash length
        const blockSize = 64;  // HMAC block size
        
        if (key.length > blockSize) {
            key = sha1(key);
        }
        
        if (key.length < blockSize) {
            const tmp = new Uint8Array(blockSize);
            tmp.set(key);
            key = tmp;
        }
        
        const iPad = new Uint8Array(blockSize);
        const oPad = new Uint8Array(blockSize);
        
        for(let i = 0; i < blockSize; i++) {
            iPad[i] = key[i] ^ 0x36;
            oPad[i] = key[i] ^ 0x5c;
        }
        
        const inner = new Uint8Array(blockSize + message.length);
        inner.set(iPad);
        inner.set(message, blockSize);
        
        const innerHash = sha1(inner);
        
        const outer = new Uint8Array(blockSize + hashLength);
        outer.set(oPad);
        outer.set(innerHash, blockSize);
        
        return sha1(outer);
    };

    // SHA1 implementation
    const sha1 = function(message) {
        const h = new Uint32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
        const w = new Uint32Array(80);
        
        // Convert message to bytes if it's not already
        const bytes = message instanceof Uint8Array ? message : new TextEncoder().encode(message);
        
        // Pre-processing
        const bitLength = bytes.length * 8;
        const chunks = Math.ceil((bytes.length + 9) / 64);
        const paddedLength = chunks * 64;
        const paddedMsg = new Uint8Array(paddedLength);
        paddedMsg.set(bytes);
        paddedMsg[bytes.length] = 0x80;
        
        const dv = new DataView(paddedMsg.buffer);
        dv.setUint32(paddedLength - 4, bitLength & 0xffffffff, false);
        dv.setUint32(paddedLength - 8, Math.floor(bitLength / 0x100000000), false);
        
        // Process chunks
        for(let chunk = 0; chunk < chunks; chunk++) {
            const offset = chunk * 64;
            
            // Fill message schedule
            for(let i = 0; i < 16; i++) {
                w[i] = dv.getUint32(offset + i * 4, false);
            }
            
            for(let i = 16; i < 80; i++) {
                w[i] = (w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16]) << 1 | (w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16]) >>> 31;
            }
            
            // Initialize working variables
            let [a, b, c, d, e] = h;
            
            // Main loop
            for(let i = 0; i < 80; i++) {
                let f, k;
                
                if(i < 20) {
                    f = (b & c) | ((~b) & d);
                    k = 0x5A827999;
                } else if(i < 40) {
                    f = b ^ c ^ d;
                    k = 0x6ED9EBA1;
                } else if(i < 60) {
                    f = (b & c) | (b & d) | (c & d);
                    k = 0x8F1BBCDC;
                } else {
                    f = b ^ c ^ d;
                    k = 0xCA62C1D6;
                }
                
                const temp = ((a << 5) | (a >>> 27)) + f + e + k + w[i];
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = temp;
            }
            
            // Update hash values
            h[0] += a;
            h[1] += b;
            h[2] += c;
            h[3] += d;
            h[4] += e;
        }
        
        // Produce final hash value
        const hash = new Uint8Array(20);
        for(let i = 0; i < 5; i++) {
            hash[i*4] = (h[i] >>> 24) & 0xff;
            hash[i*4 + 1] = (h[i] >>> 16) & 0xff;
            hash[i*4 + 2] = (h[i] >>> 8) & 0xff;
            hash[i*4 + 3] = h[i] & 0xff;
        }
        
        return hash;
    };

    // TOTP class
    class TOTP {
        constructor() {
            this.digits = 6;
            this.period = 30;
        }
        
        getOtp(secret, epoch = Math.floor(Date.now() / 1000)) {
            const counter = Math.floor(epoch / this.period);
            return this.generateOtp(secret, counter);
        }
        
        generateOtp(secret, counter) {
            // Convert counter to buffer
            const counterBuf = new Uint8Array(8);
            for(let i = 7; i >= 0; i--) {
                counterBuf[i] = counter & 0xff;
                counter = counter >>> 8;
            }
            
            // Decode secret from base32
            const key = base32Decode(secret);
            
            // Calculate HMAC
            const hash = hmacSha1(key, counterBuf);
            
            // Get offset
            const offset = hash[19] & 0xf;
            
            // Generate 4-byte code
            const code = ((hash[offset] & 0x7f) << 24) |
                        ((hash[offset + 1] & 0xff) << 16) |
                        ((hash[offset + 2] & 0xff) << 8) |
                        (hash[offset + 3] & 0xff);
            
            // Get specific number of digits
            const modulus = Math.pow(10, this.digits);
            const format = new Intl.NumberFormat('en-US', {
                minimumIntegerDigits: this.digits,
                useGrouping: false
            });
            
            return format.format(code % modulus);
        }
    }

    // Export to window
    window.jsOTP = {
        totp: TOTP
    };
})(window);
